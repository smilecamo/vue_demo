# 首屏速度、白屏时间
首屏速度=白屏时间（资源加载时间+首屏js执行时间）+渲染界面（首屏数据请求+dom渲染）
## 首屏速度
### 收益很大的操作
#### 减少首屏资源体积
1. 打包工具的压缩
2. 异步加载组件分情况---一些首屏用不到的组件或者库异步加载
3. 更新为体积更小的新版本----比如说有些库的老版本不支持tree-sharking，但是新版本的支持，这时候就可以考使用心得版本，比如xlsx,
4. 能不用第三方库就不用第三方库,比如说只是一个日期的格式化，就没有必要引入第三方库
5. 编写的时候，尽量使其精简，减少体积
6. 去除大的base64，打包工具会把一些小的图片编译成base64到js或css里面，这个时候可以进行操作
7. 收益不是很大的
8. 首屏数据尽量并行请求，如果是小数据的话，比如就一个状态，看看是不是可以合并到同一个请求中
9. 页面包含大量dom的时候，可以滚动渲染或者异步渲染
10. 当以上操作都做了，还是不如人意，就加骨架屏、loading，先让屏幕不白，减少用户焦虑
## 操作速度和渲染速度
什么情况下会造成操作卡顿或者渲染慢
1. 一次性操作大量dom
2. 进行了复杂的很高的计算常见于循环
3. vue和react项目，不必要渲染太多
解决方案
1. 一次性渲染大量dom，可以长列表渲染和异步渲染
2. 循环中操作尽量精简
### vue中的渲染优化
Vue中有依赖收集，配合上vue3的静态节点标记，已经基本上避免了因为数据改变而引起的无意义渲染，但是还是有一些点
1. 频繁切换隐藏的内容使用v-show 也就是通过display来控制，而只有一次打开的使用v-if,去创建和销毁
2. 循环、动态切换的内容设置好key
3. keep-alive缓存
4. 区分请求粒度，减少请求范围，也能减少更新，比如一个页面有下拉搜索这个搜索需要请求数据，然后还要一个表格，表格的数据发生变换，需要重新请求表格数据，这个时候就分开请求，不要放到一个函数里面
### 数据缓存
1. 不变的数据、定期失效的数据可缓存到localStorage中，比如token。用户下信息
2. 可以考虑做一个缓存队列，存于内存（全局对象、vuex），这样就可以保证刷新就能更新数据，也可以在一定程度上缓存数据