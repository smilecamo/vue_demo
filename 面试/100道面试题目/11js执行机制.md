# js 执行

js 是解释型语言，需要在代码执行时编译为机器语言
任何 JavaScript 引擎都包括一个调用栈和一个堆，

1. 调用栈是执行代码的地方
2. 堆是一个非结构化的内存池，来用于存储应用程序所需的所有对象
   由于计算机处理器只能理解二进制 0，1，所以必须将代码转换为 0，1
   当代码片段进入到引擎时，代码首先会被解析（parser）为抽象语法树（AST）的数据结构，然后会通过 Interpreter 转为 ByteCode(字节) profiler-compiler-optimaedcode
   词法分析-解析-汇编-执行

## v8 处理过程

1. 始于网络中获取 js 代码
2. v8 解析源代码，将其转换成抽象语法树（AST）
3. 基于该 AST，ignition 解释器开始做事情，产生字节码
4. 在此期间，引擎开始运行代码并且收集类型反馈
5. 为了使运行更快，字节码可以和反馈数据一起发到优化编辑器，优化编辑器在此基础上做某些假设，然后产生高度优化的机器代码
6. 在某些时候，其中一个假设被证明不正确，优化编辑器就会取消优化，会回到解释器中

# GC 垃圾回收

写代码创建一个基本数据类型、对象、函数时，都是需要占内存的，这是引擎自动分配的，不需要人为显示分配，

- 不可达的时候，就可以视作是垃圾

## 引用计数法

记录每个变量被使用的次数，当声明值的时候引用次数就为 1，该值赋给另一个变量，次数加一，该变量被其他值覆盖了，引用次数减 1，当引用次数为 0，就说明变量没有被使用了，变成了不可达状态，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间

### 优点

1. 看起来比标记清除清晰很多，首先是在引用次数为 0 的时候会被立即回收，可以立即回收垃圾
2. 标记清除会每隔一段时间执行一次，那么就会造成运行过程中会暂停的执行一段时间的 gc
3. 标记清除需要遍历堆里的活动和非活动对象来清除，而引用计数只需在引用时计数就行了

### 缺点

1. 需要一个定时器，这个计时器会占很大位置，因为也不知道引用次数上限
2. 无法解除循环引用无法回收的问题

```js
function test() {
  let a = function () {};
  let b = function () {};
  a.b = b;
  b, (a = a);
}
```

## 标记清除法

标记清除法分为两个阶段，标记阶段和清除阶段，

1. 标记阶段会在所有活动对象(具备可达性)上做标记
2. 清除阶段会把没有标记非活动对象(不具备可达性)进行销毁,使其能够再次利用

### 分配

回收垃圾的目的是为了再次分配使用
策略
first-fit 发现大于等于 size 的分块立即返回
best-fit 找到大小相当的返回
worst-fit 找到最大的块，然后分割成 size 大小和剩余大小，这个会产生很多小的分块

### 缺点

1. 内存碎片化，空闲内存是不连续的，容易出现很多空闲内存块，可能在分配内存过大的对象时找不到适合的块
2. 分配速度慢，复杂度为 On,需要遍历查找
3. 本质是清除之后剩余的对象位置不变，导致了空闲内存不连续

## 标记整理清除法

会在标记清除法之上，在标记结束后标记整理清除算法会把活着的对象（不需要清理的对象）向内存的一侧移动·，最后清除掉边界的内存

## 查看内存是否泄露

使用 performance 和 Memory 分析内存和性能

## v8 分代式垃圾回收机制

将堆内存分为新生代和老生代，采用不同的策略进行垃圾回收

### 新生代 1-8M

新、小、存活时间短的对象称为新生代，采用一小块内存频率较高的快速清理

1. 使用区
   新加入的对象会被存储到使用区，当使用区快被写满的时候，垃圾清理执行操作，清理之前会对使用区进行标记，标记完成后使用区还在活跃的对象会被复制到空闲区，清理完成之后，会把使用区和空闲区进行互换
2. 空闲区

- 当一个对象被多次复制依然存活，会移动到老生代
- 当空闲区空间占比超过 25%,会整体移动到老生代，然后翻转使用区和空闲区，25%是为了避免后续影响内存分配

### 老生代

大、老、存活时间长的称老生代
使用频繁并且短时间不会清理的，这个时候我们可以使用标记整理清除法来进行处理

## 如何优化减少内存使用

1. 减少查找 ，使用局部变量保存相关数据
2. 减少变量声明，循环体中抽离出不变的数据

# 事件循环 event lopp

## 宏任务

1. I/O
2. setTimeout setTimeout 的实际执行时间一般要比其设定的时间晚一些。setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同
3. setInterval
4. setImmediate
5. requestAnimateFrame 请求动画帧 能保证回调函数在屏幕每一次的刷新间隔中只被执行一次

## 微任务
1. process.nextTick
2. MutationObserver 接口提供了监视对 DOM 树所做更改的能力
3. promise.then catch finally
## event loop
1. 执行同步代码-执行一个宏任务（整个js执行过程可以称为一个宏任务）栈没有就从事件队列中取  
2. 执行过程中遇到微任务，加到微任务队列中  
3. 宏任务执行完-立即依次执行微任务队列中的微任务  
4. 当前宏任务执行完，开始检查渲染然后GUI线程接管渲染  
5. 渲染完成后，js线程继续接管，开始下一个宏任务（从事件队列中取）  
# 线程、进程
**线程-进程当中的一条执行流程,是最小执行单元**  
进程-运行中的程序,Process中至少有一个线程   
浏览器是多进程多线程  
所以浏览器的多进程主要是为了解决某一页面渲染崩溃导致其他页面都崩溃掉 这就是为什么tab增加后 renderer进程增加 而其他进程不变
## 进程
1. 浏览器主进程-协调控制其他子进程，浏览器的前进后退收藏，交互等，存储功能  
2. 第三方插件进程-每种类型的插件都对应一个进程，使用插件才会创建  
3. GPU 进程-3d 渲染  
4. 渲染进程也就是常说的内核-负责页面渲染，每个 tab 页面一个渲染进程，为了安全考虑渲染进程运行在沙箱模式下  
5. 网络进程-负责页面的网络加载  
## 线程
1. GUI渲染线程
2. JavaScript引擎线程
3. 定时器触发线程
4. 事件触发线程
5. 异步http请求线程
GUI线程和JS引擎是互斥的